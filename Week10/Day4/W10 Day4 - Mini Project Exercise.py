# -*- coding: utf-8 -*-
"""Adv.SQL Mini Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qfm-Z-gIj4I8vCM4r9YQ7r-QR3Z5OKBC
"""

import numpy as np # linear algebra
import pandas as pd
import sqlite3

df_olist_customers = pd.read_csv('/content/olist_customers_dataset.csv')
df_olist_sellers = pd.read_csv('/content/olist_sellers_dataset.csv')
df_olist_order_reviews= pd.read_csv('/content/olist_order_reviews_dataset.csv')
df_olist_order_items= pd.read_csv('/content/olist_order_items_dataset.csv')
df_olist_products= pd.read_csv('/content/olist_products_dataset.csv')
df_olist_geolocation= pd.read_csv('/content/olist_geolocation_dataset.csv')
df_product_category_name_translation= pd.read_csv('/content/product_category_name_translation.csv')
df_olist_orders = pd.read_csv('/content/olist_orders_dataset.csv')
df_olist_order_payments= pd.read_csv('/content/olist_order_payments_dataset.csv')

df_olist_customers.head()

from sqlalchemy import create_engine
engine = create_engine('sqlite://', echo=False)

# export the dataframe as a table 'playstore' to the sqlite engine
df_olist_customers.to_sql("olist_customers", con =engine)
df_olist_sellers.to_sql("olist_sellers", con =engine)
df_olist_order_reviews.to_sql("olist_order_reviews", con =engine)
df_olist_order_items.to_sql("olist_order_items", con =engine)
df_olist_products.to_sql("olist_products_dataset", con =engine)
df_olist_geolocation.to_sql("olist_geolocation", con =engine)
df_product_category_name_translation.to_sql("product_category_name_translation", con =engine)
df_olist_orders.to_sql("olist_orders", con =engine)
df_olist_order_payments.to_sql("olist_order_payments", con =engine)
df_olist_order_payments.head()

# TEST
sql='''
Select * from olist_customers
limit 5
''';


df_sql = pd.read_sql_query(sql,con=engine)
df_sql.head()

"""Create a SQLite database using SQLAlchemy."""

# Import necessary libraries
from sqlalchemy import create_engine

# Step 1: Create an SQLite engine
# The SQLite database file will be saved in the current working directory
# 'sqlite:///your_database_name.db' means SQLite will create a file with the name 'your_database_name.db'
engine = create_engine('sqlite:///my_new_database.db', echo=True)

# Step 2: Check if the engine is working by creating a connection
connection = engine.connect()

# Now the database 'my_new_database.db' is created and stored in the file system.
# You can use the engine to execute SQL queries or load tables (as we've already done with your dataframes).

"""Export each dataframe as a table to the SQLite database."""

from sqlalchemy import create_engine, inspect
# Step 2: Export the dataframes as tables in the SQLite database
# Assuming you already have the following dataframes loaded in memory

# Export each dataframe as a table in the SQLite database
df_olist_customers.to_sql("olist_customers", con=engine, if_exists='replace', index=False)
df_olist_sellers.to_sql("olist_sellers", con=engine, if_exists='replace', index=False)
df_olist_order_reviews.to_sql("olist_order_reviews", con=engine, if_exists='replace', index=False)
df_olist_order_items.to_sql("olist_order_items", con=engine, if_exists='replace', index=False)
df_olist_products.to_sql("olist_products", con=engine, if_exists='replace', index=False)
df_olist_geolocation.to_sql("olist_geolocation", con=engine, if_exists='replace', index=False)
df_product_category_name_translation.to_sql("product_category_name_translation", con=engine, if_exists='replace', index=False)
df_olist_orders.to_sql("olist_orders", con=engine, if_exists='replace', index=False)
df_olist_order_payments.to_sql("olist_order_payments", con=engine, if_exists='replace', index=False)

# Step 3: Use the inspect function to list all table names
inspector = inspect(engine)
table_list = inspector.get_table_names()
print("Tables in the database:", table_list)

"""Write and execute a SQL query to count the number of orders purchased in January 2018 that have a review score of 5 and calculate the percentage of such orders."""

# The SQL query to count the number of five-star orders in January 2018 and calculate their percentage
query = """
WITH jan_2018_orders AS (
    SELECT o.order_id, r.review_score
    FROM olist_orders o
    JOIN olist_order_reviews r
    ON o.order_id = r.order_id
    WHERE strftime('%Y-%m', o.order_purchase_timestamp) = '2018-01'
)

-- Count orders with review score 5 and calculate the percentage
SELECT
    COUNT(CASE WHEN review_score = 5 THEN 1 END) AS count_five_star_orders,
    (COUNT(CASE WHEN review_score = 5 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_five_star_orders
FROM jan_2018_orders;
"""

# Run the query using pandas
result = pd.read_sql_query(query, engine)

# Display the result
print(result)

"""Write and execute a SQL query to analyze the customer purchase trend year-on-year."""

# SQL query to analyze customer purchase trend year-on-year
query = """
SELECT
    strftime('%Y', order_purchase_timestamp) AS order_year, -- Extract year
    COUNT(order_id) AS total_orders -- Count orders per year
FROM
    olist_orders
GROUP BY
    order_year
ORDER BY
    order_year;
"""

# Execute the query
result = pd.read_sql_query(query, engine)

# Display the result
print(result)

"""Write and execute a SQL query to calculate the average order values of customers."""

# SQL query to calculate the average order value of customers
query = """
SELECT
    o.customer_id, -- Identify the customer
    AVG(oi.price + oi.freight_value) AS avg_order_value -- Calculate average order value
FROM
    olist_orders o
JOIN
    olist_order_items oi
ON
    o.order_id = oi.order_id
GROUP BY
    o.customer_id -- Group by customer to get individual averages
ORDER BY
    avg_order_value DESC; -- Optional: Sort to see customers with highest average order value
"""

# Execute the query
result = pd.read_sql_query(query, engine)

# Display the result
print(result)

"""Write and execute a SQL query to find the top 5 cities with the highest revenue from 2016 to 2018."""

# SQL query to find the top 5 cities with the highest revenue from 2016 to 2018
query = """
WITH revenue_data AS (
    -- Calculate total revenue for each order and join with customer and order information
    SELECT
        c.customer_city AS city,
        SUM(oi.price + oi.freight_value) AS total_revenue
    FROM
        olist_orders o
    JOIN
        olist_order_items oi
    ON
        o.order_id = oi.order_id
    JOIN
        olist_customers c
    ON
        o.customer_id = c.customer_id
    WHERE
        strftime('%Y', o.order_purchase_timestamp) BETWEEN '2016' AND '2018'
    GROUP BY
        c.customer_city
)
-- Select the top 5 cities by revenue
SELECT
    city,
    total_revenue
FROM
    revenue_data
ORDER BY
    total_revenue DESC
LIMIT 5;
"""

# Execute the query
result = pd.read_sql_query(query, engine)

# Display the result
print(result)

"""Write and execute a SQL query to create a state-wise revenue table between 2016 to 2018."""

# SQL query to create a state-wise revenue table between 2016 and 2018
query = """
WITH state_wise_revenue AS (
    -- Calculate total revenue for each order and join with customer and order information
    SELECT
        c.customer_state AS state, -- Get the state
        SUM(oi.price + oi.freight_value) AS total_revenue -- Calculate total revenue for each order
    FROM
        olist_orders o
    JOIN
        olist_order_items oi
    ON
        o.order_id = oi.order_id
    JOIN
        olist_customers c
    ON
        o.customer_id = c.customer_id
    WHERE
        strftime('%Y', o.order_purchase_timestamp) BETWEEN '2016' AND '2018' -- Filter for 2016-2018
    GROUP BY
        c.customer_state -- Group by state to get state-wise revenue
)
-- Select the state and the total revenue
SELECT
    state,
    total_revenue
FROM
    state_wise_revenue
ORDER BY
    total_revenue DESC; -- Optional: Sort by revenue to see highest-revenue states first
"""

# Execute the query
result = pd.read_sql_query(query, engine)

# Display the result
print(result)

"""Write and execute a SQL query to identify the top successful sellers in terms of the number of goods sold, total revenue, customer count, and sellers with the highest 5-star ratings."""

# SQL query to identify top successful sellers based on goods sold, revenue, customer count, and 5-star ratings
query = """
WITH seller_performance AS (
    -- Join the necessary tables to calculate total revenue, goods sold, customer count, and 5-star reviews
    SELECT
        s.seller_id, -- Identify seller
        COUNT(oi.order_id) AS total_goods_sold, -- Number of goods sold
        SUM(oi.price + oi.freight_value) AS total_revenue, -- Total revenue (price + freight)
        COUNT(DISTINCT o.customer_id) AS customer_count, -- Unique customers count
        COUNT(CASE WHEN r.review_score = 5 THEN 1 END) AS five_star_reviews -- 5-star review count
    FROM
        olist_sellers s
    JOIN
        olist_order_items oi ON s.seller_id = oi.seller_id
    JOIN
        olist_orders o ON oi.order_id = o.order_id
    LEFT JOIN
        olist_order_reviews r ON o.order_id = r.order_id
    GROUP BY
        s.seller_id
)
-- Select top sellers based on various metrics
SELECT
    seller_id,
    total_goods_sold,
    total_revenue,
    customer_count,
    five_star_reviews
FROM
    seller_performance
ORDER BY
    total_goods_sold DESC, -- Sort by number of goods sold
    total_revenue DESC, -- Sort by total revenue
    customer_count DESC, -- Sort by customer count
    five_star_reviews DESC -- Sort by 5-star reviews
LIMIT 10; -- Get top 10 sellers
"""

# Execute the query
result = pd.read_sql_query(query, engine)

# Display the result
print(result)

"""Write and execute a SQL query to calculate the delivery success rate across different states.

"""

# SQL query to calculate the delivery success rate across different states
query = """
WITH state_delivery_data AS (
    -- Create a subquery that calculates whether each order was successfully delivered
    SELECT
        c.customer_state AS state,
        CASE
            WHEN o.order_delivered_customer_date <= o.order_estimated_delivery_date
            THEN 1
            ELSE 0
        END AS delivery_success -- Check if the order was delivered on or before the estimated date
    FROM
        olist_orders o
    JOIN
        olist_customers c ON o.customer_id = c.customer_id
    WHERE
        o.order_delivered_customer_date IS NOT NULL -- Exclude orders that haven't been delivered yet
)

-- Calculate the success rate for each state
SELECT
    state,
    SUM(delivery_success) AS successful_deliveries, -- Total successful deliveries
    COUNT(*) AS total_deliveries, -- Total deliveries
    (SUM(delivery_success) * 100.0 / COUNT(*)) AS success_rate -- Calculate success rate percentage
FROM
    state_delivery_data
GROUP BY
    state
ORDER BY
    success_rate DESC; -- Sort by highest success rate
"""

# Execute the query
result = pd.read_sql_query(query, engine)

# Display the result
print(result)

"""Write and execute a SQL query to find the preferred form of payment for different product categories."""

# SQL query to find the preferred form of payment for different product categories
query = """
WITH payment_counts AS (
    -- Join tables to get product categories and payment methods
    SELECT
        p.product_category_name AS category,
        py.payment_type AS payment_method,
        COUNT(py.payment_type) AS payment_count -- Count payment method usage
    FROM
        olist_order_items oi
    JOIN
        olist_products p ON oi.product_id = p.product_id -- Join to get product categories
    JOIN
        olist_orders o ON oi.order_id = o.order_id -- Join to connect orders with order items
    JOIN
        olist_order_payments py ON o.order_id = py.order_id -- Join to get payment methods
    GROUP BY
        p.product_category_name, py.payment_type -- Group by product category and payment method
)
-- Now we select the preferred payment method (highest count) for each product category
SELECT
    category,
    payment_method,
    MAX(payment_count) AS max_count
FROM
    payment_counts
GROUP BY
    category
ORDER BY
    max_count DESC;
"""

# Execute the query
result = pd.read_sql_query(query, engine)

# Display the result
print(result)

"""Write and execute a SQL query to calculate the distance between cities"""

# SQL query to calculate the distance between cities using the Haversine formula
query = """
WITH city_pairs AS (
    -- Self-join the geolocation table to create pairs of cities
    SELECT
        g1.geolocation_city AS city1,
        g2.geolocation_city AS city2,
        g1.geolocation_lat AS lat1,
        g1.geolocation_lng AS lon1,
        g2.geolocation_lat AS lat2,
        g2.geolocation_lng AS lon2
    FROM
        olist_geolocation g1
    JOIN
        olist_geolocation g2
    ON
        g1.geolocation_city <> g2.geolocation_city -- Avoid pairing a city with itself
)
-- Calculate the Haversine distance between city pairs
SELECT
    city1,
    city2,
    (6371 * acos(cos(radians(lat1)) * cos(radians(lat2)) * cos(radians(lon2) - radians(lon1)) + sin(radians(lat1)) * sin(radians(lat2)))) AS distance_km
FROM
    city_pairs
ORDER BY
    distance_km;
"""

# Execute the query
result = pd.read_sql_query(query, engine)

# Display the result
print(result)